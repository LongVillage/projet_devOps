#############################################
# .gitlab-ci.yml
#############################################
stages:
  - build
  - infra
  - deploy

# Variables : stocke la plupart dans l'UI GitLab > Settings > CI/CD > Variables
# ex: $AWS_ACCESS_KEY_ID, $AWS_SECRET_ACCESS_KEY, $AWS_DEFAULT_REGION, ...
# ex: $AWS_ECR_REGISTRY, $AWS_ECR_TOKEN (ou on fait un aws ecr get-login-password)

build-docker:
  stage: build
  image: docker:20.10.16
  services:
    - docker:dind
  variables:
    DOCKER_HOST: "tcp://docker:2375/"
  script:
    # 1) Se connecter à ECR (ou DockerHub)
    - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ECR_REGISTRY

    # 2) Build + push Django
    - cd services/predict-model/Django
    - docker build -t django-crypto:latest .
    - docker tag django-crypto:latest $AWS_ECR_REGISTRY/dockerimage/djangocrypto:latest
    - docker push $AWS_ECR_REGISTRY/dockerimage/djangocrypto:latest
    - cd ../..

    # 3) Build + push Streamlit
    - cd services/predict-model/streamlit
    - docker build -t streamlit-crypto:latest .
    - docker tag streamlit-crypto:latest $AWS_ECR_REGISTRY/dockerimage/streamlitcrypto:latest
    - docker push $AWS_ECR_REGISTRY/dockerimage/streamlitcrypto:latest
    - cd ../..
  only:
    - main

infra:
  stage: infra
  image: hashicorp/terraform:1.3.9
  script:
    - cd services/predict-model/terraform
    - terraform init
    - terraform plan -out=tfplan
    - terraform apply -auto-approve tfplan
  artifacts:
    paths:
      - services/predict-model/terraform/terraform.tfstate
    expire_in: 1 week
  only:
    - main

deploy:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    # 1) Configurer kubectl pour accéder au cluster. Ex:
    #    aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name myekscrypto
    - aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name myekscrypto

    # 2) On applique tous les manifests (Ingress, Deployments, Services, etc.)
    - kubectl apply -f services/predict-model/k8s/
    # L'Ingress est créé => un ALB va se créer

    # 3) Attendre un peu que l'ALB apparaisse
    - echo "Waiting 30s for ALB..."
    - sleep 30

    # 4) Récupérer le DNS de l'ALB
    - export ALB_DNS=$(kubectl get ingress crypto-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
    - echo "ALB DNS is $ALB_DNS"

    # 5) Mettre à jour la ConfigMap => STREAMLIT_URL
    - sed -i "s|STREAMLIT_URL:.*|STREAMLIT_URL: \"http://$ALB_DNS/streamlit\"|g" services/predict-model/k8s/configmap.yaml
    - kubectl apply -f services/predict-model/k8s/configmap.yaml

    # 6) Redémarrer Django pour qu'il prenne la nouvelle env
    - kubectl rollout restart deployment django-deployment
    - kubectl get pods
  dependencies:
    - infra
  only:
    - main
